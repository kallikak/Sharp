#include <MIDI.h>
#include "USBHost_t36.h"

#include "Utilities.h"
#include "Sharp.h"
#include "MIDIManager.h"
#include "noteset.h"
#include "notetracker.h"
#include "arpeggiator.h"

#define ECHO_TO_SERIAL 0

extern notetracker tracker;
extern arpeggiator arpeggiators[];

extern bool transposing;
extern devicestate state;

void handleNoteOn(byte channel, byte pitch, byte velocity);
void handleNoteOff(byte channel, byte pitch, byte velocity);
void handlePitchBend(byte channel, int  bend);
void handleControlChange(byte channel, byte number, byte value);

#define MAXNOTEEVENT 200

bool waitingForCycle = false;

typedef struct
{
  int clock;
  byte note;
  byte velocity;
} note_event;

typedef struct
{
  devicestate state;
  note_event events[MAXNOTEEVENT];
} sequence;

#define MIN_NOTE 1
#define MAX_NOTE 127

bool replayNotes[MAX_NOTE + 1] = {false};

int eventIndex = 0;
int eventCount = 14;
int clockOffset = 0;
bool recording = false;
bool replayOn = false;
int replayoffset = 0;
bool replayEvent = false;

sequence seq;

void addEvent(long clock, byte pitch, byte velocity);
void checkReplay(long curClock);
void transposeReplay(int offset);
void setDemoSequence();

extern bool settingsplit;

#define CV_NOTE A22
#define CV_CTRL A21
#define CV_GATE 27
#define CV_CLK  26
#define GATE_HIGH 568  // approximately 5V

MIDI_CREATE_DEFAULT_INSTANCE();
//MIDI_CREATE_INSTANCE(HardwareSerial, Serial1, MIDI);

static USBHost usbHost;
static USBHIDParser hid1(usbHost);
static USBHIDParser hid2(usbHost);
static USBHub hub1(usbHost);
static MIDIDevice usbmidi(usbHost);

void handleControlChange(byte channel, byte number, byte value)
{
  Serial.print("Control change: ");
  Serial.print(number);
  Serial.print(" = ");
  Serial.println(value); 
}

void setupMIDI()
{
  pinMode(CV_GATE, OUTPUT);
  pinMode(CV_CLK, OUTPUT);
  digitalWrite(CV_GATE, 0);
  digitalWrite(CV_CLK, 0);
  
  MIDI.begin(1);
  MIDI.turnThruOff();

  // all notes off
  stopallnotes();

  MIDI.setHandleNoteOn(handleNoteOn);
  MIDI.setHandleNoteOff(handleNoteOff);
  MIDI.setHandlePitchBend(handlePitchBend);

  usbMIDI.setHandleNoteOn(handleNoteOn);
  usbMIDI.setHandleNoteOff(handleNoteOff);
  usbMIDI.setHandlePitchChange(handlePitchBend);
  
  usbHost.begin();
  usbmidi.setHandleNoteOn(handleNoteOn);
  usbmidi.setHandleNoteOff(handleNoteOff);
//  usbmidi.setHandleClock(handleClock);
//  usbmidi.setHandleStart(handleStart);
//  usbmidi.setHandleContinue(handleContinue);
//  usbmidi.setHandleStop(handleStop);

  Serial.println("MIDI setup complete");
  
  setDemoSequence();
}

int noteToCV(byte note)
{
  // 9V range => 9 octaves, so volts per semitone is 0.083333
  // and 1023 = 9V, so scaling factor is 1023 / 12 / 9 = 9.47222
  // MIDI numbers A0 is 21, C8 is 108 (so 87 notes)
  // But max output is actually only 8.2, so correct this to 1023 / 12 / 8.2 = 10.396341
  // p->value / 1023.0 * 8.2

  return round((min(108, max(0, note)) - 21) * 10.396341);
}

void sendNoteOn(byte channel, byte note, byte velocity)
{
//  char *nstr = getnotestring(note, true);
//  DBG2n("Note on: ", nstr)DBG(channel)
  if (replayRunning())
  {
    note += replayoffset;
    replayNotes[note] = true;
  }
  MIDI.sendNoteOn(note, velocity, channel);
  usbMIDI.sendNoteOn(note, velocity, channel);
  usbmidi.sendNoteOn(note, velocity, channel);

/*    If mode == ARPBOTH or split2
 *      send channel 1 to cv1
 *      send channel 2 to cv2
 *    else
 *      send all to both cvs
 *    end
 */
  int cv = noteToCV(note);
  if (curmode == ARPBOTH && state.common.active)
  {
    analogWrite(channel == 1 ? CV_NOTE : CV_CTRL, cv);
    digitalWrite(channel == 1 ? CV_GATE : CV_CLK, 1);
  }
  else if (curcommon->split == 2)
  {
    if (channel == 2)
    {
      analogWrite(CV_CTRL, cv);
      digitalWrite(CV_CLK, 1);
    }
    else
    {
      analogWrite(CV_NOTE, cv);
      digitalWrite(CV_GATE, 1);
    }
  }
  else
  {
    analogWrite(CV_NOTE, cv);
    digitalWrite(CV_GATE, 1);
    analogWrite(CV_CTRL, cv);
    digitalWrite(CV_CLK, 1);
  }
}

void sendNoteOff(byte channel, byte note, byte velocity)
{
//  char *nstr = getnotestring(note, true);
//  DBG2n("Note off: ", nstr)DBG(channel)
  if (replayRunning())
  {
    note += replayoffset;
    replayNotes[note] = false;
  }
  
  MIDI.sendNoteOff(note, velocity, channel);
  usbMIDI.sendNoteOff(note, velocity, channel);
  usbmidi.sendNoteOff(note, velocity, channel);
//  if (curmode == ARPBOTH || curcommon->split == 2)
//  {
//    digitalWrite(channel == 1 ? CV_GATE : CV_CLK, 0);
//  }
  if (curmode == ARPBOTH)
  {
    digitalWrite(channel == 1 ? CV_GATE : CV_CLK, 0);
  }
  else if (curcommon->split == 2)
  {
    if (channel == 2 && tracker.bypassnotes->count == 0)
      digitalWrite(CV_CLK, 0);
    else
      digitalWrite(CV_GATE, 0);
  }
  else
  {
    digitalWrite(CV_GATE, 0);
    digitalWrite(CV_CLK, 0);
  }
}

void sendPitchBend(byte channel, int bend)
{
  MIDI.sendPitchBend(bend, channel);
  usbMIDI.sendPitchBend(bend, channel);
  usbmidi.sendPitchBend(bend, channel);
}

void sendControlChange(byte channel, byte number, byte value)
{
#if ECHO_TO_SERIAL  
  Serial.print("Control change: ");
  Serial.print(number);
  Serial.print(" -> ");
  Serial.println(value);
#endif  
  MIDI.sendControlChange(number, value, channel);
}

void handlestoppednotes()
{
  noteset *stops = tracker.notestostop;
  // for (int j = 0; j < 2; ++j)
  // {
  //   noteset stops = arpeggiators[j].getnotestostop();
    for (int i = 0; i < stops->count; ++i)
    {
//      DBG2("Stopping", stops->notes[i].pitch);
      if (stops->notes[i].pitch)
      {
//        char *nstr = getnotestring(stops->notes[i].pitch, true);
//        DBG2n("Note off(*): ", nstr)DBG(stops->notes[i].channel)
        MIDI.sendNoteOff(stops->notes[i].pitch, 0x00, stops->notes[i].channel);
        usbMIDI.sendNoteOff(stops->notes[i].pitch, 0x00, stops->notes[i].channel);
        usbmidi.sendNoteOff(stops->notes[i].pitch, 0x00, stops->notes[i].channel);
        if (curmode != ARPBOTH && curcommon->split == 2)
        {
          if (stops->notes[i].channel == 2 && tracker.bypassnotes->count == 0)
            digitalWrite(CV_CLK, 0);
          else
            digitalWrite(CV_GATE, 0);
        }
        else
          digitalWrite(stops->notes[i].channel == 1 ? CV_GATE : CV_CLK, 0);
      }
    } 
  // }
}

bool isTransposeNote(byte pitch, byte velocity)
{
  return !replayEvent && replayRunning() && transposing && velocity > 0; 
}

bool isBypassNote(byte pitch, byte velocity, commonstate *common)
{
  if (!replayEvent && replayRunning() && !transposing && velocity > 0)
    return true;
  else if (common->split)
    return (curmode == ARPL && pitch >= common->splitnote) || 
      (curmode == ARPH && pitch <= common->splitnote);
  else
    return false;
}

void handleNoteOn(byte channel, byte pitch, byte velocity) 
{
  if (!pitch)
    return;

  if (isTransposeNote(pitch, velocity))
  {
    transposeReplay((int)pitch - 48);
    return;
  }
  
  if (settingsplit)
  {
    settingsplit = false;
    state.common.splitnote = pitch;
    tracker.adjustfornewsplit(pitch);
//    stopallnotes();
    handlestoppednotes();
    handleupdate();
    displayNote(state.common.splitnote, state.common.split == 2);
    return;
  }

  if (!isBypassNote(pitch, velocity, curcommon) && (tracker.getheldcount(false) == 0))
  {
    arpeggiators[0].resetnote();
    arpeggiators[1].resetnote();
  }
  tracker.tracknoteon(pitch, &state);
  lastvelocity = velocity;
  
  if (recording)
    addEvent(getClock(), pitch, velocity);

  handlestoppednotes();
  
  noteset *starts = tracker.newnotestoplay;
  if (state.common.active)
  {
    handleupdate();
//    Serial.println(getnotesetstring("Starts", starts));
    for (int i = 0; i < starts->count; ++i)
    {
      sendNoteOn(starts->notes[i].channel, starts->notes[i].pitch, velocity); 
    }
  }
  else if (starts->count)
  {
    sendNoteOn(starts->notes[0].channel, starts->notes[0].pitch, velocity); 
  }
}

void handleNoteOff(byte channel, byte pitch, byte velocity) 
{
  if (!pitch)
    return;

  if (!replayEvent && replayRunning() && setting == REPLAY && transposing)
  {
    return; // it was a transpose
  }

  if (recording)
    addEvent(getClock(), pitch, 0);
  bool bypass = tracker.isbypass(pitch, channel);
  if (tracker.tracknoteoff(pitch, &state))
  {
    handlestoppednotes();
    if (!bypass)
    {
      if (state.common.active)
        handleupdate();
      else if (tracker.getheldcount(false) == 0)
      {
        digitalWrite(CV_GATE, 0);
        digitalWrite(CV_CLK, 0);
      }
    }
  }
}

void handlePitchBend(byte channel, int bend)
{
  MIDI.sendPitchBend(bend, channel);
  usbMIDI.sendPitchBend(bend, channel);
  usbmidi.sendPitchBend(bend, channel);
}

//void handleControlChange(byte channel, byte number, byte value)
//{
//  MIDI.sendControlChange(number, value, channel);
//}

void stopallnotes()
{
  MIDI.sendControlChange(123, 0, 1);
  MIDI.sendControlChange(123, 0, 2);
  usbMIDI.sendControlChange(123, 0, 1);
  usbMIDI.sendControlChange(123, 0, 2);
  usbmidi.sendControlChange(123, 0, 1);
  usbmidi.sendControlChange(123, 0, 2);
  stopcv();
  tracker.resettracker();
}

void stopcv()
{
  digitalWrite(CV_GATE, 0);
  digitalWrite(CV_CLK, 0); 
}

void checkMIDI(long curClock)
{
  MIDI.read();
  usbMIDI.read();
  usbHost.Task();
  usbmidi.read();
  checkReplay(curClock);
}

void setDemoSequence()
{
  seq = {
    {
      ARPL,
      { false, false, 60, true },
      {
        { false, 4, 4, SHUFFLE, false, DOUBLE3, 1, CLOCKTRIGGER, 0 },
        { false, 4, 4, SHUFFLE, false, DOUBLE3, 1, CLOCKTRIGGER, 0 }
      }
    },
    {
      {0, 50, 127},
      {0, 53, 127},
      {0, 57, 127},         // D F A
      {4 * 96 * 12, 59, 127},    // D F A B
      {8 * 96 * 12, 53, 0},      // D A B
      {12 * 96 * 12, 48, 127},   // C D A B
      {16 * 96 * 12, 50, 0},     
      {16 * 96 * 12, 51, 127},   // C Eb A B
      {20 * 96 * 12, 59, 0},
      {20 * 96 * 12, 57, 0},
      {20 * 96 * 12, 55, 127},   // C Eb G
      {24 * 96 * 12, 48, 0},
      {24 * 96 * 12, 51, 0},
      {24 * 96 * 12, 49, 127},
      {24 * 96 * 12, 52, 127},   
      {24 * 96 * 12, 57, 127},   // C# E G A
      {28 * 96 * 12, 57, 127},   
      {28 * 96 * 12, 0}
    }
  };
}

bool isRecording()
{
  return recording;
}

void clearReplayNotes()
{
  for (int i = MIN_NOTE; i <= MAX_NOTE; ++i)
    replayNotes[i] = false;
}

int countReplayNotes()
{
  int c = 0;
  for (int i = MIN_NOTE; i <= MAX_NOTE; ++i)
    if (replayNotes[i])
      c++;
  return c;
}

bool hasReplayNote()
{
  int c = 0;
  for (int i = MIN_NOTE; i <= MAX_NOTE; ++i)
    if (replayNotes[i])
      c++;
  return c;
}

void startRecordingSequence()
{
  recording = true;
  seq.state = state;
  for (int i = 0; i < MAXNOTEEVENT; ++i)
    seq.events[i] = {0, 0, 0};
  clearReplayNotes();
  eventCount = 0;
}

void addEvent(long clock, byte pitch, byte velocity)
{
  seq.events[eventCount] = {clock, pitch, velocity};
  replayNotes[pitch] = velocity > 0;
  eventCount++;
  if (eventCount == MAXNOTEEVENT)
    endRecordingSequence(clock);
}

void endRecordingSequence(long curClock)
{
  recording = false;  
  if (!eventCount)
    setDemoSequence();
  else
  {
    long startclock = seq.events[0].clock;
    for (int i = 0; i < MAXNOTEEVENT; ++i)
    {
      if (!seq.events[i].clock)
        break;
      seq.events[i].clock -= startclock;
    }
    if (eventCount < MAXNOTEEVENT)
    {
      long finalclock;
//      if (hasReplayNote())
//      {
        // FIXME - timebase handling...
//        long cycles = ceil(curClock / 24 / state.timebase);
//        finalclock = cycles * 24 * state.timebase - startclock;
        long cycles = ceil(curClock / 24);
        finalclock = cycles * 24 - startclock;
//      }
//      else
//      {
//        finalclock = curClock - startclock;
//      }
      seq.events[eventCount] = {finalclock, 0, 0};
      eventCount++;
    }
    Serial.println("Recording");
    for (int i = 0; i < MAXNOTEEVENT; ++i)
    {
      if (!seq.events[i].clock && !seq.events[i].note)
        break;
      Serial.print(i);Serial.print("\t");
      Serial.print(seq.events[i].clock);Serial.print(": ");
      Serial.print(seq.events[i].note);Serial.println(seq.events[i].velocity ? " on" : " off");
    }
  }
}

int getEventCount()
{
  return eventCount;
}

bool replayRunning()
{
  return replayOn;  
}

void startReplay(long curClock)
{
  clockOffset = curClock;
  waitingForCycle = false;
  bool saveactive = state.common.active;
  state = seq.state;
  state.common.active = saveactive;
  replayOn = true;
  eventIndex = 0;
  replayoffset = 0;
  clearReplayNotes();
  showState();
  handleupdate();
}

void transposeReplay(int newoffset)
{
  if (replayoffset == newoffset)
    return;
    
  bool reverse = newoffset > replayoffset;
  int delta = newoffset - replayoffset;
  int start = reverse ? MAX_NOTE : MIN_NOTE;  
  int end = reverse ? MIN_NOTE : MAX_NOTE;
  int step = reverse ? -1 : 1;
  for (int i = start; i != end; i += step)
  {
    if (replayNotes[i])
    {
      replayNotes[i] = false;
      sendNoteOff(1, i, 0);
      replayNotes[i + delta] = true;
      sendNoteOn(1, i + delta, lastvelocity);
    }
  }
  
  replayoffset = newoffset;
}

void endReplay()
{
  replayOn = false;
  stopallnotes();
  clearReplayNotes();
}

void handleEvent(note_event e)
{
  byte n = e.note;
  if (n < MIN_NOTE || n > MAX_NOTE)
    return;
  replayEvent = true;
  if (e.velocity)
  {
    handleNoteOn(1, n, e.velocity);
  }
  else
  {
    handleNoteOff(1, n, 0);
  }
  replayEvent = false;
}

void notifyCycle(long curClock)
{
  if (waitingForCycle)
  { 
    // time the reset to match the start of a cycle
    eventIndex = 0;
    waitingForCycle = false;
    clockOffset = curClock;
    stopallnotes();
    checkReplay(curClock);
  }
}

void checkReplay(long curClock)
{
  if (!replayOn)// || waitingForCycle)
    return;
    
  note_event nextEvent = seq.events[eventIndex];
  while (nextEvent.clock + clockOffset <= curClock)
  {
#if DEBUG_SERIAL    
    Serial.print("Event: ");
    Serial.print(nextEvent.clock);
    Serial.print(": ");
    Serial.print(nextEvent.note);
    Serial.println(nextEvent.velocity ? " on " : " off");
#endif    
    int c = countReplayNotes();
#if DEBUG_SERIAL    
    Serial.print("Note count: ");
    Serial.println(c);
#endif    
    if (!nextEvent.note)
    {
      // are we at the end and no notes held?
      bool hasNote = hasReplayNote();
#if DEBUG_SERIAL    
      Serial.print("Waiting for cycle with hasNote = ");
      Serial.println(hasNote);
#endif    
      waitingForCycle = true;
//      if (state.mode == RANDOM || !hasNote)
      {
#if DEBUG_SERIAL    
        Serial.println("Immediate notify");
#endif    
        notifyCycle(curClock);
      }
      return;
    }
    handleEvent(nextEvent);
    eventIndex++;
    nextEvent = seq.events[eventIndex];
  }
}

int getTransposeOffset()
{
  return replayoffset;
}
